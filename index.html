<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Solana Transaction Graph</title>
  <script src="https://unpkg.com/vis-network@9.1.0/standalone/umd/vis-network.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 20px;
      background: #f9f9f9;
    }
    #controls {
      margin-bottom: 10px;
    }
    #addr {
      width: 320px;
      padding: 6px;
      font-size: 1rem;
    }
    #go {
      padding: 6px 12px;
      font-size: 1rem;
    }
    #network {
      width: 100%;
      height: 80vh;
      border: 1px solid #ccc;
      background: #fff;
    }
  </style>
</head>
<body>
  <div id="controls">
    <input id="addr" placeholder="Enter Solana address…" />
    <button id="go">Draw Graph</button>
  </div>
  <div id="network"></div>

  <script>
  async function rpc(method, params) {
    const res = await fetch("/.netlify/functions/proxy", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ method, params })
    });
    const j = await res.json();
    if (j.error) throw j.error;
    return j.result;
  }

  function abbreviate(addr) {
    return addr.slice(0,6) + "…" + addr.slice(-6);
  }

  async function draw(addr) {
    const container = document.getElementById("network");
    container.innerHTML = ""; h

    try {
      const sigInfos = await rpc("getSignaturesForAddress", [addr, { limit: 100 }]);
      const sigs = sigInfos.map(s => s.signature);

      const txPromises = sigs.map(sig =>
        rpc("getTransaction", [sig, { encoding: "jsonParsed", maxSupportedTransactionVersion: 0 }])
      );
      const txs = await Promise.all(txPromises);

      const nodesSeen = new Set();
      nodesSeen.add(addr);
      const edges = [];

      txs.forEach(tx => {
        if (!tx || !tx.transaction) return;
        const instrs = tx.transaction.message.instructions || [];
        instrs.forEach(instr => {
          const p = instr.parsed;
          if (p && p.type === "transfer") {
            const src = p.info.source, dst = p.info.destination;
            if (src !== addr && dst !== addr) return;  // only include edges touching center
            nodesSeen.add(src);
            nodesSeen.add(dst);
            edges.push({ from: src, to: dst });
          }
        });
      });

      const visNodes = Array.from(nodesSeen).map(id => ({
        id,
        label: id === addr ? id : abbreviate(id),
        title: id,
        color: id === addr ? "red" : "lightblue",
        size: id === addr ? 30 : 15
      }));
      const edgeMap = {};
      edges.forEach(e => {
        const key = e.from + "->" + e.to;
        edgeMap[key] = (edgeMap[key] || 0) + 1;
      });
      const visEdges = Object.entries(edgeMap).map(([key, w]) => {
        const [from, to] = key.split("->");
        return {
          from, to,
          color: to === addr ? "green" : "red",
          arrows: "to",
          value: w
        };
      });

      const data = { nodes: visNodes, edges: visEdges };
      const options = {
        physics: {
          barnesHut: {
            gravitationalConstant: -3000,
            springLength: 200,
            springConstant: 0.05
          }
        }
      };
      const network = new vis.Network(container, data, options);

      network.on("click", params => {
        if (params.nodes.length) {
          const nodeId = params.nodes[0];
          window.open("https://explorer.solana.com/address/" + nodeId, "_blank");
        }
      });

    } catch (err) {
      console.error(err);
      alert("Error: " + (err.message||err));
    }
  }

  document.getElementById("go").onclick = () => {
    const a = document.getElementById("addr").value.trim();
    if (a) draw(a);
  };
  </script>
</body>
</html>
